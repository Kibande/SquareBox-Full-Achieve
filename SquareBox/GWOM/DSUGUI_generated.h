// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DSUGUI_SQUAREBOX_DSUGUI_H_
#define FLATBUFFERS_GENERATED_DSUGUI_SQUAREBOX_DSUGUI_H_

#include "flatbuffers/flatbuffers.h"

namespace SquareBox {
namespace DSUGUI {

struct PairOfInt;
struct PairOfIntBuilder;

struct Vec2;

struct Vec3;

struct Vec4;

struct Ivec2;

struct Ivec3;

struct Ivec4;

struct PairOfVec2;
struct PairOfVec2Builder;

struct GLTexture;
struct GLTextureBuilder;

struct SpriteFont;
struct SpriteFontBuilder;

struct TextureInfo;
struct TextureInfoBuilder;

struct FontInfo;
struct FontInfoBuilder;

struct GUIElement;
struct GUIElementBuilder;

struct SquareBoxGuiLayer;
struct SquareBoxGuiLayerBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Ivec2()
      : x_(0),
        y_(0) {
  }
  Ivec2(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  Ivec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Ivec3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  Ivec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Ivec4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec4, 16);

struct PairOfInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairOfIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST = 4,
    VT_SECOND = 6
  };
  int32_t first() const {
    return GetField<int32_t>(VT_FIRST, 0);
  }
  int32_t second() const {
    return GetField<int32_t>(VT_SECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRST) &&
           VerifyField<int32_t>(verifier, VT_SECOND) &&
           verifier.EndTable();
  }
};

struct PairOfIntBuilder {
  typedef PairOfInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(int32_t first) {
    fbb_.AddElement<int32_t>(PairOfInt::VT_FIRST, first, 0);
  }
  void add_second(int32_t second) {
    fbb_.AddElement<int32_t>(PairOfInt::VT_SECOND, second, 0);
  }
  explicit PairOfIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairOfInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairOfInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairOfInt> CreatePairOfInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t first = 0,
    int32_t second = 0) {
  PairOfIntBuilder builder_(_fbb);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

struct PairOfVec2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairOfVec2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST = 4,
    VT_SECOND = 6
  };
  const SquareBox::DSUGUI::Vec2 *first() const {
    return GetStruct<const SquareBox::DSUGUI::Vec2 *>(VT_FIRST);
  }
  const SquareBox::DSUGUI::Vec2 *second() const {
    return GetStruct<const SquareBox::DSUGUI::Vec2 *>(VT_SECOND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SquareBox::DSUGUI::Vec2>(verifier, VT_FIRST) &&
           VerifyField<SquareBox::DSUGUI::Vec2>(verifier, VT_SECOND) &&
           verifier.EndTable();
  }
};

struct PairOfVec2Builder {
  typedef PairOfVec2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(const SquareBox::DSUGUI::Vec2 *first) {
    fbb_.AddStruct(PairOfVec2::VT_FIRST, first);
  }
  void add_second(const SquareBox::DSUGUI::Vec2 *second) {
    fbb_.AddStruct(PairOfVec2::VT_SECOND, second);
  }
  explicit PairOfVec2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairOfVec2>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairOfVec2> CreatePairOfVec2(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SquareBox::DSUGUI::Vec2 *first = 0,
    const SquareBox::DSUGUI::Vec2 *second = 0) {
  PairOfVec2Builder builder_(_fbb);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

struct GLTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLTextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSETS_FILE_PATH = 4,
    VT_DISPLAY_NAME = 6,
    VT_TILING = 8
  };
  const flatbuffers::String *assets_file_path() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSETS_FILE_PATH);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  const SquareBox::DSUGUI::Ivec2 *tiling() const {
    return GetStruct<const SquareBox::DSUGUI::Ivec2 *>(VT_TILING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSETS_FILE_PATH) &&
           verifier.VerifyString(assets_file_path()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<SquareBox::DSUGUI::Ivec2>(verifier, VT_TILING) &&
           verifier.EndTable();
  }
};

struct GLTextureBuilder {
  typedef GLTexture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_assets_file_path(flatbuffers::Offset<flatbuffers::String> assets_file_path) {
    fbb_.AddOffset(GLTexture::VT_ASSETS_FILE_PATH, assets_file_path);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(GLTexture::VT_DISPLAY_NAME, display_name);
  }
  void add_tiling(const SquareBox::DSUGUI::Ivec2 *tiling) {
    fbb_.AddStruct(GLTexture::VT_TILING, tiling);
  }
  explicit GLTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLTexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLTexture>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLTexture> CreateGLTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> assets_file_path = 0,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    const SquareBox::DSUGUI::Ivec2 *tiling = 0) {
  GLTextureBuilder builder_(_fbb);
  builder_.add_tiling(tiling);
  builder_.add_display_name(display_name);
  builder_.add_assets_file_path(assets_file_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLTexture> CreateGLTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *assets_file_path = nullptr,
    const char *display_name = nullptr,
    const SquareBox::DSUGUI::Ivec2 *tiling = 0) {
  auto assets_file_path__ = assets_file_path ? _fbb.CreateString(assets_file_path) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return SquareBox::DSUGUI::CreateGLTexture(
      _fbb,
      assets_file_path__,
      display_name__,
      tiling);
}

struct SpriteFont FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpriteFontBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FONT_PATH = 4,
    VT_DISPLAY_NAME = 6,
    VT_FONT_SIZE = 8
  };
  const flatbuffers::String *font_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT_PATH);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  int32_t font_size() const {
    return GetField<int32_t>(VT_FONT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FONT_PATH) &&
           verifier.VerifyString(font_path()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<int32_t>(verifier, VT_FONT_SIZE) &&
           verifier.EndTable();
  }
};

struct SpriteFontBuilder {
  typedef SpriteFont Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_font_path(flatbuffers::Offset<flatbuffers::String> font_path) {
    fbb_.AddOffset(SpriteFont::VT_FONT_PATH, font_path);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(SpriteFont::VT_DISPLAY_NAME, display_name);
  }
  void add_font_size(int32_t font_size) {
    fbb_.AddElement<int32_t>(SpriteFont::VT_FONT_SIZE, font_size, 0);
  }
  explicit SpriteFontBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpriteFont> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpriteFont>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpriteFont> CreateSpriteFont(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> font_path = 0,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    int32_t font_size = 0) {
  SpriteFontBuilder builder_(_fbb);
  builder_.add_font_size(font_size);
  builder_.add_display_name(display_name);
  builder_.add_font_path(font_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteFont> CreateSpriteFontDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *font_path = nullptr,
    const char *display_name = nullptr,
    int32_t font_size = 0) {
  auto font_path__ = font_path ? _fbb.CreateString(font_path) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return SquareBox::DSUGUI::CreateSpriteFont(
      _fbb,
      font_path__,
      display_name__,
      font_size);
}

struct TextureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURE_TYPE = 4,
    VT_TEXTURE_INDEX = 6,
    VT_TILE_SHEET_INDEX = 8,
    VT_TEXTURE_ID = 10,
    VT_UV_RECT = 12,
    VT_COLOR = 14,
    VT_OPACITY = 16
  };
  int32_t texture_type() const {
    return GetField<int32_t>(VT_TEXTURE_TYPE, 0);
  }
  int32_t texture_index() const {
    return GetField<int32_t>(VT_TEXTURE_INDEX, 0);
  }
  int32_t tile_sheet_index() const {
    return GetField<int32_t>(VT_TILE_SHEET_INDEX, 0);
  }
  int32_t texture_id() const {
    return GetField<int32_t>(VT_TEXTURE_ID, 0);
  }
  const SquareBox::DSUGUI::Vec4 *uv_rect() const {
    return GetStruct<const SquareBox::DSUGUI::Vec4 *>(VT_UV_RECT);
  }
  const SquareBox::DSUGUI::Ivec4 *color() const {
    return GetStruct<const SquareBox::DSUGUI::Ivec4 *>(VT_COLOR);
  }
  int32_t opacity() const {
    return GetField<int32_t>(VT_OPACITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TILE_SHEET_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_ID) &&
           VerifyField<SquareBox::DSUGUI::Vec4>(verifier, VT_UV_RECT) &&
           VerifyField<SquareBox::DSUGUI::Ivec4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_OPACITY) &&
           verifier.EndTable();
  }
};

struct TextureInfoBuilder {
  typedef TextureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texture_type(int32_t texture_type) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_TYPE, texture_type, 0);
  }
  void add_texture_index(int32_t texture_index) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_INDEX, texture_index, 0);
  }
  void add_tile_sheet_index(int32_t tile_sheet_index) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TILE_SHEET_INDEX, tile_sheet_index, 0);
  }
  void add_texture_id(int32_t texture_id) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_ID, texture_id, 0);
  }
  void add_uv_rect(const SquareBox::DSUGUI::Vec4 *uv_rect) {
    fbb_.AddStruct(TextureInfo::VT_UV_RECT, uv_rect);
  }
  void add_color(const SquareBox::DSUGUI::Ivec4 *color) {
    fbb_.AddStruct(TextureInfo::VT_COLOR, color);
  }
  void add_opacity(int32_t opacity) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_OPACITY, opacity, 0);
  }
  explicit TextureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureInfo> CreateTextureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t texture_type = 0,
    int32_t texture_index = 0,
    int32_t tile_sheet_index = 0,
    int32_t texture_id = 0,
    const SquareBox::DSUGUI::Vec4 *uv_rect = 0,
    const SquareBox::DSUGUI::Ivec4 *color = 0,
    int32_t opacity = 0) {
  TextureInfoBuilder builder_(_fbb);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_uv_rect(uv_rect);
  builder_.add_texture_id(texture_id);
  builder_.add_tile_sheet_index(tile_sheet_index);
  builder_.add_texture_index(texture_index);
  builder_.add_texture_type(texture_type);
  return builder_.Finish();
}

struct FontInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FontInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_FONT_INDEX = 6,
    VT_TEXT = 8,
    VT_SHOW_TEXT = 10,
    VT_TEXT_TO_BOX_HEIGHT_SCALE = 12,
    VT_OPACITY = 14,
    VT_JUSTIFICATION = 16
  };
  const SquareBox::DSUGUI::Ivec4 *color() const {
    return GetStruct<const SquareBox::DSUGUI::Ivec4 *>(VT_COLOR);
  }
  int32_t font_index() const {
    return GetField<int32_t>(VT_FONT_INDEX, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool show_text() const {
    return GetField<uint8_t>(VT_SHOW_TEXT, 0) != 0;
  }
  float text_to_box_height_scale() const {
    return GetField<float>(VT_TEXT_TO_BOX_HEIGHT_SCALE, 0.0f);
  }
  int32_t opacity() const {
    return GetField<int32_t>(VT_OPACITY, 0);
  }
  int32_t justification() const {
    return GetField<int32_t>(VT_JUSTIFICATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SquareBox::DSUGUI::Ivec4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_FONT_INDEX) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_TEXT) &&
           VerifyField<float>(verifier, VT_TEXT_TO_BOX_HEIGHT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_OPACITY) &&
           VerifyField<int32_t>(verifier, VT_JUSTIFICATION) &&
           verifier.EndTable();
  }
};

struct FontInfoBuilder {
  typedef FontInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(const SquareBox::DSUGUI::Ivec4 *color) {
    fbb_.AddStruct(FontInfo::VT_COLOR, color);
  }
  void add_font_index(int32_t font_index) {
    fbb_.AddElement<int32_t>(FontInfo::VT_FONT_INDEX, font_index, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(FontInfo::VT_TEXT, text);
  }
  void add_show_text(bool show_text) {
    fbb_.AddElement<uint8_t>(FontInfo::VT_SHOW_TEXT, static_cast<uint8_t>(show_text), 0);
  }
  void add_text_to_box_height_scale(float text_to_box_height_scale) {
    fbb_.AddElement<float>(FontInfo::VT_TEXT_TO_BOX_HEIGHT_SCALE, text_to_box_height_scale, 0.0f);
  }
  void add_opacity(int32_t opacity) {
    fbb_.AddElement<int32_t>(FontInfo::VT_OPACITY, opacity, 0);
  }
  void add_justification(int32_t justification) {
    fbb_.AddElement<int32_t>(FontInfo::VT_JUSTIFICATION, justification, 0);
  }
  explicit FontInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FontInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FontInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FontInfo> CreateFontInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SquareBox::DSUGUI::Ivec4 *color = 0,
    int32_t font_index = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    bool show_text = false,
    float text_to_box_height_scale = 0.0f,
    int32_t opacity = 0,
    int32_t justification = 0) {
  FontInfoBuilder builder_(_fbb);
  builder_.add_justification(justification);
  builder_.add_opacity(opacity);
  builder_.add_text_to_box_height_scale(text_to_box_height_scale);
  builder_.add_text(text);
  builder_.add_font_index(font_index);
  builder_.add_color(color);
  builder_.add_show_text(show_text);
  return builder_.Finish();
}

inline flatbuffers::Offset<FontInfo> CreateFontInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SquareBox::DSUGUI::Ivec4 *color = 0,
    int32_t font_index = 0,
    const char *text = nullptr,
    bool show_text = false,
    float text_to_box_height_scale = 0.0f,
    int32_t opacity = 0,
    int32_t justification = 0) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return SquareBox::DSUGUI::CreateFontInfo(
      _fbb,
      color,
      font_index,
      text__,
      show_text,
      text_to_box_height_scale,
      opacity,
      justification);
}

struct GUIElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUIElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_STATE = 6,
    VT_ID = 8,
    VT_NAME = 10,
    VT_IS_HIDDEN = 12,
    VT_IS_LOCKED = 14,
    VT_LOCATION_RATIO = 16,
    VT_HEIGHT_RATIO = 18,
    VT_WIDTH_RATIO = 20,
    VT_RADIUS_RATIO = 22,
    VT_ANGLE = 24,
    VT_IS_ALIVE = 26,
    VT_FONTS = 28,
    VT_TEXTURES = 30
  };
  int32_t shape() const {
    return GetField<int32_t>(VT_SHAPE, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool is_hidden() const {
    return GetField<uint8_t>(VT_IS_HIDDEN, 0) != 0;
  }
  bool is_locked() const {
    return GetField<uint8_t>(VT_IS_LOCKED, 0) != 0;
  }
  const SquareBox::DSUGUI::Vec2 *location_ratio() const {
    return GetStruct<const SquareBox::DSUGUI::Vec2 *>(VT_LOCATION_RATIO);
  }
  float height_ratio() const {
    return GetField<float>(VT_HEIGHT_RATIO, 0.0f);
  }
  float width_ratio() const {
    return GetField<float>(VT_WIDTH_RATIO, 0.0f);
  }
  float radius_ratio() const {
    return GetField<float>(VT_RADIUS_RATIO, 0.0f);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  bool is_alive() const {
    return GetField<uint8_t>(VT_IS_ALIVE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>> *fonts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>> *>(VT_FONTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>> *>(VT_TEXTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHAPE) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_HIDDEN) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOCKED) &&
           VerifyField<SquareBox::DSUGUI::Vec2>(verifier, VT_LOCATION_RATIO) &&
           VerifyField<float>(verifier, VT_HEIGHT_RATIO) &&
           VerifyField<float>(verifier, VT_WIDTH_RATIO) &&
           VerifyField<float>(verifier, VT_RADIUS_RATIO) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<uint8_t>(verifier, VT_IS_ALIVE) &&
           VerifyOffset(verifier, VT_FONTS) &&
           verifier.VerifyVector(fonts()) &&
           verifier.VerifyVectorOfTables(fonts()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           verifier.EndTable();
  }
};

struct GUIElementBuilder {
  typedef GUIElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(int32_t shape) {
    fbb_.AddElement<int32_t>(GUIElement::VT_SHAPE, shape, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(GUIElement::VT_STATE, state, 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(GUIElement::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GUIElement::VT_NAME, name);
  }
  void add_is_hidden(bool is_hidden) {
    fbb_.AddElement<uint8_t>(GUIElement::VT_IS_HIDDEN, static_cast<uint8_t>(is_hidden), 0);
  }
  void add_is_locked(bool is_locked) {
    fbb_.AddElement<uint8_t>(GUIElement::VT_IS_LOCKED, static_cast<uint8_t>(is_locked), 0);
  }
  void add_location_ratio(const SquareBox::DSUGUI::Vec2 *location_ratio) {
    fbb_.AddStruct(GUIElement::VT_LOCATION_RATIO, location_ratio);
  }
  void add_height_ratio(float height_ratio) {
    fbb_.AddElement<float>(GUIElement::VT_HEIGHT_RATIO, height_ratio, 0.0f);
  }
  void add_width_ratio(float width_ratio) {
    fbb_.AddElement<float>(GUIElement::VT_WIDTH_RATIO, width_ratio, 0.0f);
  }
  void add_radius_ratio(float radius_ratio) {
    fbb_.AddElement<float>(GUIElement::VT_RADIUS_RATIO, radius_ratio, 0.0f);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(GUIElement::VT_ANGLE, angle, 0.0f);
  }
  void add_is_alive(bool is_alive) {
    fbb_.AddElement<uint8_t>(GUIElement::VT_IS_ALIVE, static_cast<uint8_t>(is_alive), 0);
  }
  void add_fonts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>>> fonts) {
    fbb_.AddOffset(GUIElement::VT_FONTS, fonts);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>>> textures) {
    fbb_.AddOffset(GUIElement::VT_TEXTURES, textures);
  }
  explicit GUIElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GUIElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUIElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUIElement> CreateGUIElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shape = 0,
    int32_t state = 0,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_hidden = false,
    bool is_locked = false,
    const SquareBox::DSUGUI::Vec2 *location_ratio = 0,
    float height_ratio = 0.0f,
    float width_ratio = 0.0f,
    float radius_ratio = 0.0f,
    float angle = 0.0f,
    bool is_alive = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>>> fonts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>>> textures = 0) {
  GUIElementBuilder builder_(_fbb);
  builder_.add_textures(textures);
  builder_.add_fonts(fonts);
  builder_.add_angle(angle);
  builder_.add_radius_ratio(radius_ratio);
  builder_.add_width_ratio(width_ratio);
  builder_.add_height_ratio(height_ratio);
  builder_.add_location_ratio(location_ratio);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_state(state);
  builder_.add_shape(shape);
  builder_.add_is_alive(is_alive);
  builder_.add_is_locked(is_locked);
  builder_.add_is_hidden(is_hidden);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUIElement> CreateGUIElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shape = 0,
    int32_t state = 0,
    int32_t id = 0,
    const char *name = nullptr,
    bool is_hidden = false,
    bool is_locked = false,
    const SquareBox::DSUGUI::Vec2 *location_ratio = 0,
    float height_ratio = 0.0f,
    float width_ratio = 0.0f,
    float radius_ratio = 0.0f,
    float angle = 0.0f,
    bool is_alive = false,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>> *fonts = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>> *textures = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fonts__ = fonts ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::FontInfo>>(*fonts) : 0;
  auto textures__ = textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::TextureInfo>>(*textures) : 0;
  return SquareBox::DSUGUI::CreateGUIElement(
      _fbb,
      shape,
      state,
      id,
      name__,
      is_hidden,
      is_locked,
      location_ratio,
      height_ratio,
      width_ratio,
      radius_ratio,
      angle,
      is_alive,
      fonts__,
      textures__);
}

struct SquareBoxGuiLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareBoxGuiLayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GUI_ELEMENTS = 4,
    VT_SINGLE_TEXTURES = 6,
    VT_TILED_TEXTURES = 8,
    VT_SPRITE_FONTS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>> *gui_elements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>> *>(VT_GUI_ELEMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *single_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *>(VT_SINGLE_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *tiled_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *>(VT_TILED_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>> *sprite_fonts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>> *>(VT_SPRITE_FONTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GUI_ELEMENTS) &&
           verifier.VerifyVector(gui_elements()) &&
           verifier.VerifyVectorOfTables(gui_elements()) &&
           VerifyOffset(verifier, VT_SINGLE_TEXTURES) &&
           verifier.VerifyVector(single_textures()) &&
           verifier.VerifyVectorOfTables(single_textures()) &&
           VerifyOffset(verifier, VT_TILED_TEXTURES) &&
           verifier.VerifyVector(tiled_textures()) &&
           verifier.VerifyVectorOfTables(tiled_textures()) &&
           VerifyOffset(verifier, VT_SPRITE_FONTS) &&
           verifier.VerifyVector(sprite_fonts()) &&
           verifier.VerifyVectorOfTables(sprite_fonts()) &&
           verifier.EndTable();
  }
};

struct SquareBoxGuiLayerBuilder {
  typedef SquareBoxGuiLayer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gui_elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>>> gui_elements) {
    fbb_.AddOffset(SquareBoxGuiLayer::VT_GUI_ELEMENTS, gui_elements);
  }
  void add_single_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>> single_textures) {
    fbb_.AddOffset(SquareBoxGuiLayer::VT_SINGLE_TEXTURES, single_textures);
  }
  void add_tiled_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>> tiled_textures) {
    fbb_.AddOffset(SquareBoxGuiLayer::VT_TILED_TEXTURES, tiled_textures);
  }
  void add_sprite_fonts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>>> sprite_fonts) {
    fbb_.AddOffset(SquareBoxGuiLayer::VT_SPRITE_FONTS, sprite_fonts);
  }
  explicit SquareBoxGuiLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquareBoxGuiLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareBoxGuiLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareBoxGuiLayer> CreateSquareBoxGuiLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>>> gui_elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>> single_textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>> tiled_textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>>> sprite_fonts = 0) {
  SquareBoxGuiLayerBuilder builder_(_fbb);
  builder_.add_sprite_fonts(sprite_fonts);
  builder_.add_tiled_textures(tiled_textures);
  builder_.add_single_textures(single_textures);
  builder_.add_gui_elements(gui_elements);
  return builder_.Finish();
}

inline flatbuffers::Offset<SquareBoxGuiLayer> CreateSquareBoxGuiLayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>> *gui_elements = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *single_textures = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>> *tiled_textures = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>> *sprite_fonts = nullptr) {
  auto gui_elements__ = gui_elements ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::GUIElement>>(*gui_elements) : 0;
  auto single_textures__ = single_textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>(*single_textures) : 0;
  auto tiled_textures__ = tiled_textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::GLTexture>>(*tiled_textures) : 0;
  auto sprite_fonts__ = sprite_fonts ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGUI::SpriteFont>>(*sprite_fonts) : 0;
  return SquareBox::DSUGUI::CreateSquareBoxGuiLayer(
      _fbb,
      gui_elements__,
      single_textures__,
      tiled_textures__,
      sprite_fonts__);
}

inline const SquareBox::DSUGUI::SquareBoxGuiLayer *GetSquareBoxGuiLayer(const void *buf) {
  return flatbuffers::GetRoot<SquareBox::DSUGUI::SquareBoxGuiLayer>(buf);
}

inline const SquareBox::DSUGUI::SquareBoxGuiLayer *GetSizePrefixedSquareBoxGuiLayer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SquareBox::DSUGUI::SquareBoxGuiLayer>(buf);
}

inline bool VerifySquareBoxGuiLayerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SquareBox::DSUGUI::SquareBoxGuiLayer>(nullptr);
}

inline bool VerifySizePrefixedSquareBoxGuiLayerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SquareBox::DSUGUI::SquareBoxGuiLayer>(nullptr);
}

inline void FinishSquareBoxGuiLayerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SquareBox::DSUGUI::SquareBoxGuiLayer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSquareBoxGuiLayerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SquareBox::DSUGUI::SquareBoxGuiLayer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DSUGUI
}  // namespace SquareBox

#endif  // FLATBUFFERS_GENERATED_DSUGUI_SQUAREBOX_DSUGUI_H_
