// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DSUGWOM_SQUAREBOX_DSUGWOM_H_
#define FLATBUFFERS_GENERATED_DSUGWOM_SQUAREBOX_DSUGWOM_H_

#include "flatbuffers/flatbuffers.h"

namespace SquareBox {
namespace DSUGWOM {

struct PairOfInt;
struct PairOfIntBuilder;

struct Vec2;

struct Vec3;

struct Vec4;

struct Ivec2;

struct Ivec3;

struct Ivec4;

struct PairOfVec2;
struct PairOfVec2Builder;

struct GLTexture;
struct GLTextureBuilder;

struct ParentTexture;
struct ParentTextureBuilder;

struct SubTexture;
struct SubTextureBuilder;

struct TextureInfo;
struct TextureInfoBuilder;

struct VectorOfInt;
struct VectorOfIntBuilder;

struct Joint;
struct JointBuilder;

struct ClusterObject;
struct ClusterObjectBuilder;

struct WorldCluster;
struct WorldClusterBuilder;

struct Layer;
struct LayerBuilder;

struct SquareBoxLevel;
struct SquareBoxLevelBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Ivec2()
      : x_(0),
        y_(0) {
  }
  Ivec2(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  Ivec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Ivec3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ivec4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  Ivec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Ivec4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Ivec4, 16);

struct PairOfInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairOfIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST = 4,
    VT_SECOND = 6
  };
  int32_t first() const {
    return GetField<int32_t>(VT_FIRST, 0);
  }
  int32_t second() const {
    return GetField<int32_t>(VT_SECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRST) &&
           VerifyField<int32_t>(verifier, VT_SECOND) &&
           verifier.EndTable();
  }
};

struct PairOfIntBuilder {
  typedef PairOfInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(int32_t first) {
    fbb_.AddElement<int32_t>(PairOfInt::VT_FIRST, first, 0);
  }
  void add_second(int32_t second) {
    fbb_.AddElement<int32_t>(PairOfInt::VT_SECOND, second, 0);
  }
  explicit PairOfIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairOfInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairOfInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairOfInt> CreatePairOfInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t first = 0,
    int32_t second = 0) {
  PairOfIntBuilder builder_(_fbb);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

struct PairOfVec2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairOfVec2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST = 4,
    VT_SECOND = 6
  };
  const SquareBox::DSUGWOM::Vec2 *first() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_FIRST);
  }
  const SquareBox::DSUGWOM::Vec2 *second() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_SECOND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_FIRST) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_SECOND) &&
           verifier.EndTable();
  }
};

struct PairOfVec2Builder {
  typedef PairOfVec2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(const SquareBox::DSUGWOM::Vec2 *first) {
    fbb_.AddStruct(PairOfVec2::VT_FIRST, first);
  }
  void add_second(const SquareBox::DSUGWOM::Vec2 *second) {
    fbb_.AddStruct(PairOfVec2::VT_SECOND, second);
  }
  explicit PairOfVec2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairOfVec2>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairOfVec2> CreatePairOfVec2(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SquareBox::DSUGWOM::Vec2 *first = 0,
    const SquareBox::DSUGWOM::Vec2 *second = 0) {
  PairOfVec2Builder builder_(_fbb);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

struct GLTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLTextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSETS_FILE_PATH = 4,
    VT_DISPLAY_NAME = 6,
    VT_HEIGTH = 8,
    VT_WIDTH = 10,
    VT_TILING = 12
  };
  const flatbuffers::String *assets_file_path() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSETS_FILE_PATH);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  int32_t heigth() const {
    return GetField<int32_t>(VT_HEIGTH, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  const SquareBox::DSUGWOM::Ivec2 *tiling() const {
    return GetStruct<const SquareBox::DSUGWOM::Ivec2 *>(VT_TILING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSETS_FILE_PATH) &&
           verifier.VerifyString(assets_file_path()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<int32_t>(verifier, VT_HEIGTH) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<SquareBox::DSUGWOM::Ivec2>(verifier, VT_TILING) &&
           verifier.EndTable();
  }
};

struct GLTextureBuilder {
  typedef GLTexture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_assets_file_path(flatbuffers::Offset<flatbuffers::String> assets_file_path) {
    fbb_.AddOffset(GLTexture::VT_ASSETS_FILE_PATH, assets_file_path);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(GLTexture::VT_DISPLAY_NAME, display_name);
  }
  void add_heigth(int32_t heigth) {
    fbb_.AddElement<int32_t>(GLTexture::VT_HEIGTH, heigth, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(GLTexture::VT_WIDTH, width, 0);
  }
  void add_tiling(const SquareBox::DSUGWOM::Ivec2 *tiling) {
    fbb_.AddStruct(GLTexture::VT_TILING, tiling);
  }
  explicit GLTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLTexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLTexture>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLTexture> CreateGLTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> assets_file_path = 0,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    int32_t heigth = 0,
    int32_t width = 0,
    const SquareBox::DSUGWOM::Ivec2 *tiling = 0) {
  GLTextureBuilder builder_(_fbb);
  builder_.add_tiling(tiling);
  builder_.add_width(width);
  builder_.add_heigth(heigth);
  builder_.add_display_name(display_name);
  builder_.add_assets_file_path(assets_file_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLTexture> CreateGLTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *assets_file_path = nullptr,
    const char *display_name = nullptr,
    int32_t heigth = 0,
    int32_t width = 0,
    const SquareBox::DSUGWOM::Ivec2 *tiling = 0) {
  auto assets_file_path__ = assets_file_path ? _fbb.CreateString(assets_file_path) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return SquareBox::DSUGWOM::CreateGLTexture(
      _fbb,
      assets_file_path__,
      display_name__,
      heigth,
      width,
      tiling);
}

struct ParentTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParentTextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURE_INDEX = 4,
    VT_TEXTURE = 6
  };
  int32_t texture_index() const {
    return GetField<int32_t>(VT_TEXTURE_INDEX, 0);
  }
  const SquareBox::DSUGWOM::GLTexture *texture() const {
    return GetPointer<const SquareBox::DSUGWOM::GLTexture *>(VT_TEXTURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_INDEX) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyTable(texture()) &&
           verifier.EndTable();
  }
};

struct ParentTextureBuilder {
  typedef ParentTexture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texture_index(int32_t texture_index) {
    fbb_.AddElement<int32_t>(ParentTexture::VT_TEXTURE_INDEX, texture_index, 0);
  }
  void add_texture(flatbuffers::Offset<SquareBox::DSUGWOM::GLTexture> texture) {
    fbb_.AddOffset(ParentTexture::VT_TEXTURE, texture);
  }
  explicit ParentTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParentTexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParentTexture>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParentTexture> CreateParentTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t texture_index = 0,
    flatbuffers::Offset<SquareBox::DSUGWOM::GLTexture> texture = 0) {
  ParentTextureBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_texture_index(texture_index);
  return builder_.Finish();
}

struct SubTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubTextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARENT_TYPE = 4,
    VT_SUB_TEXTURE_KEY = 6,
    VT_PARENT_TEXTURE_INDEX = 8,
    VT_TILING_INDEX = 10
  };
  int32_t parent_type() const {
    return GetField<int32_t>(VT_PARENT_TYPE, 0);
  }
  int32_t sub_texture_key() const {
    return GetField<int32_t>(VT_SUB_TEXTURE_KEY, 0);
  }
  int32_t parent_texture_index() const {
    return GetField<int32_t>(VT_PARENT_TEXTURE_INDEX, 0);
  }
  int32_t tiling_index() const {
    return GetField<int32_t>(VT_TILING_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARENT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SUB_TEXTURE_KEY) &&
           VerifyField<int32_t>(verifier, VT_PARENT_TEXTURE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TILING_INDEX) &&
           verifier.EndTable();
  }
};

struct SubTextureBuilder {
  typedef SubTexture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parent_type(int32_t parent_type) {
    fbb_.AddElement<int32_t>(SubTexture::VT_PARENT_TYPE, parent_type, 0);
  }
  void add_sub_texture_key(int32_t sub_texture_key) {
    fbb_.AddElement<int32_t>(SubTexture::VT_SUB_TEXTURE_KEY, sub_texture_key, 0);
  }
  void add_parent_texture_index(int32_t parent_texture_index) {
    fbb_.AddElement<int32_t>(SubTexture::VT_PARENT_TEXTURE_INDEX, parent_texture_index, 0);
  }
  void add_tiling_index(int32_t tiling_index) {
    fbb_.AddElement<int32_t>(SubTexture::VT_TILING_INDEX, tiling_index, 0);
  }
  explicit SubTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubTexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubTexture>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubTexture> CreateSubTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t parent_type = 0,
    int32_t sub_texture_key = 0,
    int32_t parent_texture_index = 0,
    int32_t tiling_index = 0) {
  SubTextureBuilder builder_(_fbb);
  builder_.add_tiling_index(tiling_index);
  builder_.add_parent_texture_index(parent_texture_index);
  builder_.add_sub_texture_key(sub_texture_key);
  builder_.add_parent_type(parent_type);
  return builder_.Finish();
}

struct TextureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURE_TYPE = 4,
    VT_TEXTURE_INDEX = 6,
    VT_TILE_SHEET_INDEX = 8,
    VT_TEXTURE_ID = 10,
    VT_UV_RECT = 12
  };
  int32_t texture_type() const {
    return GetField<int32_t>(VT_TEXTURE_TYPE, 0);
  }
  int32_t texture_index() const {
    return GetField<int32_t>(VT_TEXTURE_INDEX, 0);
  }
  int32_t tile_sheet_index() const {
    return GetField<int32_t>(VT_TILE_SHEET_INDEX, 0);
  }
  int32_t texture_id() const {
    return GetField<int32_t>(VT_TEXTURE_ID, 0);
  }
  const SquareBox::DSUGWOM::Vec4 *uv_rect() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec4 *>(VT_UV_RECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TILE_SHEET_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_ID) &&
           VerifyField<SquareBox::DSUGWOM::Vec4>(verifier, VT_UV_RECT) &&
           verifier.EndTable();
  }
};

struct TextureInfoBuilder {
  typedef TextureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texture_type(int32_t texture_type) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_TYPE, texture_type, 0);
  }
  void add_texture_index(int32_t texture_index) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_INDEX, texture_index, 0);
  }
  void add_tile_sheet_index(int32_t tile_sheet_index) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TILE_SHEET_INDEX, tile_sheet_index, 0);
  }
  void add_texture_id(int32_t texture_id) {
    fbb_.AddElement<int32_t>(TextureInfo::VT_TEXTURE_ID, texture_id, 0);
  }
  void add_uv_rect(const SquareBox::DSUGWOM::Vec4 *uv_rect) {
    fbb_.AddStruct(TextureInfo::VT_UV_RECT, uv_rect);
  }
  explicit TextureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureInfo> CreateTextureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t texture_type = 0,
    int32_t texture_index = 0,
    int32_t tile_sheet_index = 0,
    int32_t texture_id = 0,
    const SquareBox::DSUGWOM::Vec4 *uv_rect = 0) {
  TextureInfoBuilder builder_(_fbb);
  builder_.add_uv_rect(uv_rect);
  builder_.add_texture_id(texture_id);
  builder_.add_tile_sheet_index(tile_sheet_index);
  builder_.add_texture_index(texture_index);
  builder_.add_texture_type(texture_type);
  return builder_.Finish();
}

struct VectorOfInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorOfIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct VectorOfIntBuilder {
  typedef VectorOfInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(VectorOfInt::VT_DATA, data);
  }
  explicit VectorOfIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorOfInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorOfInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorOfInt> CreateVectorOfInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  VectorOfIntBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorOfInt> CreateVectorOfIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return SquareBox::DSUGWOM::CreateVectorOfInt(
      _fbb,
      data__);
}

struct Joint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_A_COORDINATES = 4,
    VT_BODY_B_COORDINATES = 6,
    VT_COLLIDE_CONNECTED_BODIES = 8,
    VT_IS_JOINT_ALIVE = 10,
    VT_REFERENCE_ANGLE = 12,
    VT_FREQUENCY_HZ = 14,
    VT_DAMPING_RATIO = 16,
    VT_MAX_LENGTH = 18,
    VT_MIN_LENGTH = 20,
    VT_LENGTH = 22,
    VT_LENGTH_A = 24,
    VT_LENGTH_B = 26,
    VT_LOWER_ANGLE = 28,
    VT_LOWER_TRANSLATION = 30,
    VT_UPPER_ANGLE = 32,
    VT_UPPER_TRANSLATION = 34,
    VT_MAX_MOTOR_TORQUE = 36,
    VT_MAX_MOTOR_FORCE = 38,
    VT_MOTOR_SPEED = 40,
    VT_ENABLE_MOTOR = 42,
    VT_ENABLE_LIMIT = 44,
    VT_COLOR = 46,
    VT_THICKNESS = 48,
    VT_PULLEY_RATIO = 50,
    VT_STIFFNESS = 52,
    VT_DAMPING = 54,
    VT_GROUND_ANCHOR_A = 56,
    VT_GROUND_ANCHOR_B = 58,
    VT_LOCAL_ANCHOR_A = 60,
    VT_LOCAL_ANCHOR_B = 62,
    VT_VEC_OF_POINTS = 64,
    VT_LOCAL_AXIS_A = 66,
    VT_JOINT_TYPE = 68
  };
  const SquareBox::DSUGWOM::PairOfInt *body_a_coordinates() const {
    return GetPointer<const SquareBox::DSUGWOM::PairOfInt *>(VT_BODY_A_COORDINATES);
  }
  const SquareBox::DSUGWOM::PairOfInt *body_b_coordinates() const {
    return GetPointer<const SquareBox::DSUGWOM::PairOfInt *>(VT_BODY_B_COORDINATES);
  }
  bool collide_connected_bodies() const {
    return GetField<uint8_t>(VT_COLLIDE_CONNECTED_BODIES, 0) != 0;
  }
  bool is_joint_alive() const {
    return GetField<uint8_t>(VT_IS_JOINT_ALIVE, 0) != 0;
  }
  float reference_angle() const {
    return GetField<float>(VT_REFERENCE_ANGLE, 0.0f);
  }
  float frequency_hz() const {
    return GetField<float>(VT_FREQUENCY_HZ, 0.0f);
  }
  float damping_ratio() const {
    return GetField<float>(VT_DAMPING_RATIO, 0.0f);
  }
  float max_length() const {
    return GetField<float>(VT_MAX_LENGTH, 0.0f);
  }
  float min_length() const {
    return GetField<float>(VT_MIN_LENGTH, 0.0f);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  float length_a() const {
    return GetField<float>(VT_LENGTH_A, 0.0f);
  }
  float length_b() const {
    return GetField<float>(VT_LENGTH_B, 0.0f);
  }
  float lower_angle() const {
    return GetField<float>(VT_LOWER_ANGLE, 0.0f);
  }
  float lower_translation() const {
    return GetField<float>(VT_LOWER_TRANSLATION, 0.0f);
  }
  float upper_angle() const {
    return GetField<float>(VT_UPPER_ANGLE, 0.0f);
  }
  float upper_translation() const {
    return GetField<float>(VT_UPPER_TRANSLATION, 0.0f);
  }
  float max_motor_torque() const {
    return GetField<float>(VT_MAX_MOTOR_TORQUE, 0.0f);
  }
  float max_motor_force() const {
    return GetField<float>(VT_MAX_MOTOR_FORCE, 0.0f);
  }
  float motor_speed() const {
    return GetField<float>(VT_MOTOR_SPEED, 0.0f);
  }
  bool enable_motor() const {
    return GetField<uint8_t>(VT_ENABLE_MOTOR, 0) != 0;
  }
  bool enable_limit() const {
    return GetField<uint8_t>(VT_ENABLE_LIMIT, 0) != 0;
  }
  const SquareBox::DSUGWOM::Ivec4 *color() const {
    return GetStruct<const SquareBox::DSUGWOM::Ivec4 *>(VT_COLOR);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  float pulley_ratio() const {
    return GetField<float>(VT_PULLEY_RATIO, 0.0f);
  }
  float stiffness() const {
    return GetField<float>(VT_STIFFNESS, 0.0f);
  }
  float damping() const {
    return GetField<float>(VT_DAMPING, 0.0f);
  }
  const SquareBox::DSUGWOM::Vec2 *ground_anchor_a() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_GROUND_ANCHOR_A);
  }
  const SquareBox::DSUGWOM::Vec2 *ground_anchor_b() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_GROUND_ANCHOR_B);
  }
  const SquareBox::DSUGWOM::Vec2 *local_anchor_a() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_LOCAL_ANCHOR_A);
  }
  const SquareBox::DSUGWOM::Vec2 *local_anchor_b() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_LOCAL_ANCHOR_B);
  }
  const flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *> *vec_of_points() const {
    return GetPointer<const flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *> *>(VT_VEC_OF_POINTS);
  }
  const SquareBox::DSUGWOM::Vec2 *local_axis_a() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_LOCAL_AXIS_A);
  }
  int32_t joint_type() const {
    return GetField<int32_t>(VT_JOINT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BODY_A_COORDINATES) &&
           verifier.VerifyTable(body_a_coordinates()) &&
           VerifyOffset(verifier, VT_BODY_B_COORDINATES) &&
           verifier.VerifyTable(body_b_coordinates()) &&
           VerifyField<uint8_t>(verifier, VT_COLLIDE_CONNECTED_BODIES) &&
           VerifyField<uint8_t>(verifier, VT_IS_JOINT_ALIVE) &&
           VerifyField<float>(verifier, VT_REFERENCE_ANGLE) &&
           VerifyField<float>(verifier, VT_FREQUENCY_HZ) &&
           VerifyField<float>(verifier, VT_DAMPING_RATIO) &&
           VerifyField<float>(verifier, VT_MAX_LENGTH) &&
           VerifyField<float>(verifier, VT_MIN_LENGTH) &&
           VerifyField<float>(verifier, VT_LENGTH) &&
           VerifyField<float>(verifier, VT_LENGTH_A) &&
           VerifyField<float>(verifier, VT_LENGTH_B) &&
           VerifyField<float>(verifier, VT_LOWER_ANGLE) &&
           VerifyField<float>(verifier, VT_LOWER_TRANSLATION) &&
           VerifyField<float>(verifier, VT_UPPER_ANGLE) &&
           VerifyField<float>(verifier, VT_UPPER_TRANSLATION) &&
           VerifyField<float>(verifier, VT_MAX_MOTOR_TORQUE) &&
           VerifyField<float>(verifier, VT_MAX_MOTOR_FORCE) &&
           VerifyField<float>(verifier, VT_MOTOR_SPEED) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_MOTOR) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_LIMIT) &&
           VerifyField<SquareBox::DSUGWOM::Ivec4>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_THICKNESS) &&
           VerifyField<float>(verifier, VT_PULLEY_RATIO) &&
           VerifyField<float>(verifier, VT_STIFFNESS) &&
           VerifyField<float>(verifier, VT_DAMPING) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_GROUND_ANCHOR_A) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_GROUND_ANCHOR_B) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_LOCAL_ANCHOR_A) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_LOCAL_ANCHOR_B) &&
           VerifyOffset(verifier, VT_VEC_OF_POINTS) &&
           verifier.VerifyVector(vec_of_points()) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_LOCAL_AXIS_A) &&
           VerifyField<int32_t>(verifier, VT_JOINT_TYPE) &&
           verifier.EndTable();
  }
};

struct JointBuilder {
  typedef Joint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_a_coordinates(flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_a_coordinates) {
    fbb_.AddOffset(Joint::VT_BODY_A_COORDINATES, body_a_coordinates);
  }
  void add_body_b_coordinates(flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_b_coordinates) {
    fbb_.AddOffset(Joint::VT_BODY_B_COORDINATES, body_b_coordinates);
  }
  void add_collide_connected_bodies(bool collide_connected_bodies) {
    fbb_.AddElement<uint8_t>(Joint::VT_COLLIDE_CONNECTED_BODIES, static_cast<uint8_t>(collide_connected_bodies), 0);
  }
  void add_is_joint_alive(bool is_joint_alive) {
    fbb_.AddElement<uint8_t>(Joint::VT_IS_JOINT_ALIVE, static_cast<uint8_t>(is_joint_alive), 0);
  }
  void add_reference_angle(float reference_angle) {
    fbb_.AddElement<float>(Joint::VT_REFERENCE_ANGLE, reference_angle, 0.0f);
  }
  void add_frequency_hz(float frequency_hz) {
    fbb_.AddElement<float>(Joint::VT_FREQUENCY_HZ, frequency_hz, 0.0f);
  }
  void add_damping_ratio(float damping_ratio) {
    fbb_.AddElement<float>(Joint::VT_DAMPING_RATIO, damping_ratio, 0.0f);
  }
  void add_max_length(float max_length) {
    fbb_.AddElement<float>(Joint::VT_MAX_LENGTH, max_length, 0.0f);
  }
  void add_min_length(float min_length) {
    fbb_.AddElement<float>(Joint::VT_MIN_LENGTH, min_length, 0.0f);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(Joint::VT_LENGTH, length, 0.0f);
  }
  void add_length_a(float length_a) {
    fbb_.AddElement<float>(Joint::VT_LENGTH_A, length_a, 0.0f);
  }
  void add_length_b(float length_b) {
    fbb_.AddElement<float>(Joint::VT_LENGTH_B, length_b, 0.0f);
  }
  void add_lower_angle(float lower_angle) {
    fbb_.AddElement<float>(Joint::VT_LOWER_ANGLE, lower_angle, 0.0f);
  }
  void add_lower_translation(float lower_translation) {
    fbb_.AddElement<float>(Joint::VT_LOWER_TRANSLATION, lower_translation, 0.0f);
  }
  void add_upper_angle(float upper_angle) {
    fbb_.AddElement<float>(Joint::VT_UPPER_ANGLE, upper_angle, 0.0f);
  }
  void add_upper_translation(float upper_translation) {
    fbb_.AddElement<float>(Joint::VT_UPPER_TRANSLATION, upper_translation, 0.0f);
  }
  void add_max_motor_torque(float max_motor_torque) {
    fbb_.AddElement<float>(Joint::VT_MAX_MOTOR_TORQUE, max_motor_torque, 0.0f);
  }
  void add_max_motor_force(float max_motor_force) {
    fbb_.AddElement<float>(Joint::VT_MAX_MOTOR_FORCE, max_motor_force, 0.0f);
  }
  void add_motor_speed(float motor_speed) {
    fbb_.AddElement<float>(Joint::VT_MOTOR_SPEED, motor_speed, 0.0f);
  }
  void add_enable_motor(bool enable_motor) {
    fbb_.AddElement<uint8_t>(Joint::VT_ENABLE_MOTOR, static_cast<uint8_t>(enable_motor), 0);
  }
  void add_enable_limit(bool enable_limit) {
    fbb_.AddElement<uint8_t>(Joint::VT_ENABLE_LIMIT, static_cast<uint8_t>(enable_limit), 0);
  }
  void add_color(const SquareBox::DSUGWOM::Ivec4 *color) {
    fbb_.AddStruct(Joint::VT_COLOR, color);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(Joint::VT_THICKNESS, thickness, 0.0f);
  }
  void add_pulley_ratio(float pulley_ratio) {
    fbb_.AddElement<float>(Joint::VT_PULLEY_RATIO, pulley_ratio, 0.0f);
  }
  void add_stiffness(float stiffness) {
    fbb_.AddElement<float>(Joint::VT_STIFFNESS, stiffness, 0.0f);
  }
  void add_damping(float damping) {
    fbb_.AddElement<float>(Joint::VT_DAMPING, damping, 0.0f);
  }
  void add_ground_anchor_a(const SquareBox::DSUGWOM::Vec2 *ground_anchor_a) {
    fbb_.AddStruct(Joint::VT_GROUND_ANCHOR_A, ground_anchor_a);
  }
  void add_ground_anchor_b(const SquareBox::DSUGWOM::Vec2 *ground_anchor_b) {
    fbb_.AddStruct(Joint::VT_GROUND_ANCHOR_B, ground_anchor_b);
  }
  void add_local_anchor_a(const SquareBox::DSUGWOM::Vec2 *local_anchor_a) {
    fbb_.AddStruct(Joint::VT_LOCAL_ANCHOR_A, local_anchor_a);
  }
  void add_local_anchor_b(const SquareBox::DSUGWOM::Vec2 *local_anchor_b) {
    fbb_.AddStruct(Joint::VT_LOCAL_ANCHOR_B, local_anchor_b);
  }
  void add_vec_of_points(flatbuffers::Offset<flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *>> vec_of_points) {
    fbb_.AddOffset(Joint::VT_VEC_OF_POINTS, vec_of_points);
  }
  void add_local_axis_a(const SquareBox::DSUGWOM::Vec2 *local_axis_a) {
    fbb_.AddStruct(Joint::VT_LOCAL_AXIS_A, local_axis_a);
  }
  void add_joint_type(int32_t joint_type) {
    fbb_.AddElement<int32_t>(Joint::VT_JOINT_TYPE, joint_type, 0);
  }
  explicit JointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Joint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Joint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Joint> CreateJoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_a_coordinates = 0,
    flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_b_coordinates = 0,
    bool collide_connected_bodies = false,
    bool is_joint_alive = false,
    float reference_angle = 0.0f,
    float frequency_hz = 0.0f,
    float damping_ratio = 0.0f,
    float max_length = 0.0f,
    float min_length = 0.0f,
    float length = 0.0f,
    float length_a = 0.0f,
    float length_b = 0.0f,
    float lower_angle = 0.0f,
    float lower_translation = 0.0f,
    float upper_angle = 0.0f,
    float upper_translation = 0.0f,
    float max_motor_torque = 0.0f,
    float max_motor_force = 0.0f,
    float motor_speed = 0.0f,
    bool enable_motor = false,
    bool enable_limit = false,
    const SquareBox::DSUGWOM::Ivec4 *color = 0,
    float thickness = 0.0f,
    float pulley_ratio = 0.0f,
    float stiffness = 0.0f,
    float damping = 0.0f,
    const SquareBox::DSUGWOM::Vec2 *ground_anchor_a = 0,
    const SquareBox::DSUGWOM::Vec2 *ground_anchor_b = 0,
    const SquareBox::DSUGWOM::Vec2 *local_anchor_a = 0,
    const SquareBox::DSUGWOM::Vec2 *local_anchor_b = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *>> vec_of_points = 0,
    const SquareBox::DSUGWOM::Vec2 *local_axis_a = 0,
    int32_t joint_type = 0) {
  JointBuilder builder_(_fbb);
  builder_.add_joint_type(joint_type);
  builder_.add_local_axis_a(local_axis_a);
  builder_.add_vec_of_points(vec_of_points);
  builder_.add_local_anchor_b(local_anchor_b);
  builder_.add_local_anchor_a(local_anchor_a);
  builder_.add_ground_anchor_b(ground_anchor_b);
  builder_.add_ground_anchor_a(ground_anchor_a);
  builder_.add_damping(damping);
  builder_.add_stiffness(stiffness);
  builder_.add_pulley_ratio(pulley_ratio);
  builder_.add_thickness(thickness);
  builder_.add_color(color);
  builder_.add_motor_speed(motor_speed);
  builder_.add_max_motor_force(max_motor_force);
  builder_.add_max_motor_torque(max_motor_torque);
  builder_.add_upper_translation(upper_translation);
  builder_.add_upper_angle(upper_angle);
  builder_.add_lower_translation(lower_translation);
  builder_.add_lower_angle(lower_angle);
  builder_.add_length_b(length_b);
  builder_.add_length_a(length_a);
  builder_.add_length(length);
  builder_.add_min_length(min_length);
  builder_.add_max_length(max_length);
  builder_.add_damping_ratio(damping_ratio);
  builder_.add_frequency_hz(frequency_hz);
  builder_.add_reference_angle(reference_angle);
  builder_.add_body_b_coordinates(body_b_coordinates);
  builder_.add_body_a_coordinates(body_a_coordinates);
  builder_.add_enable_limit(enable_limit);
  builder_.add_enable_motor(enable_motor);
  builder_.add_is_joint_alive(is_joint_alive);
  builder_.add_collide_connected_bodies(collide_connected_bodies);
  return builder_.Finish();
}

inline flatbuffers::Offset<Joint> CreateJointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_a_coordinates = 0,
    flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt> body_b_coordinates = 0,
    bool collide_connected_bodies = false,
    bool is_joint_alive = false,
    float reference_angle = 0.0f,
    float frequency_hz = 0.0f,
    float damping_ratio = 0.0f,
    float max_length = 0.0f,
    float min_length = 0.0f,
    float length = 0.0f,
    float length_a = 0.0f,
    float length_b = 0.0f,
    float lower_angle = 0.0f,
    float lower_translation = 0.0f,
    float upper_angle = 0.0f,
    float upper_translation = 0.0f,
    float max_motor_torque = 0.0f,
    float max_motor_force = 0.0f,
    float motor_speed = 0.0f,
    bool enable_motor = false,
    bool enable_limit = false,
    const SquareBox::DSUGWOM::Ivec4 *color = 0,
    float thickness = 0.0f,
    float pulley_ratio = 0.0f,
    float stiffness = 0.0f,
    float damping = 0.0f,
    const SquareBox::DSUGWOM::Vec2 *ground_anchor_a = 0,
    const SquareBox::DSUGWOM::Vec2 *ground_anchor_b = 0,
    const SquareBox::DSUGWOM::Vec2 *local_anchor_a = 0,
    const SquareBox::DSUGWOM::Vec2 *local_anchor_b = 0,
    const std::vector<SquareBox::DSUGWOM::Vec2> *vec_of_points = nullptr,
    const SquareBox::DSUGWOM::Vec2 *local_axis_a = 0,
    int32_t joint_type = 0) {
  auto vec_of_points__ = vec_of_points ? _fbb.CreateVectorOfStructs<SquareBox::DSUGWOM::Vec2>(*vec_of_points) : 0;
  return SquareBox::DSUGWOM::CreateJoint(
      _fbb,
      body_a_coordinates,
      body_b_coordinates,
      collide_connected_bodies,
      is_joint_alive,
      reference_angle,
      frequency_hz,
      damping_ratio,
      max_length,
      min_length,
      length,
      length_a,
      length_b,
      lower_angle,
      lower_translation,
      upper_angle,
      upper_translation,
      max_motor_torque,
      max_motor_force,
      motor_speed,
      enable_motor,
      enable_limit,
      color,
      thickness,
      pulley_ratio,
      stiffness,
      damping,
      ground_anchor_a,
      ground_anchor_b,
      local_anchor_a,
      local_anchor_b,
      vec_of_points__,
      local_axis_a,
      joint_type);
}

struct ClusterObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClusterObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER_INDEX = 4,
    VT_CLUSTER_INDEX = 6,
    VT_INDEX = 8,
    VT_DELETION_INDEX = 10,
    VT_LIFE_SPAN = 12,
    VT_GROUP_INDEX = 14,
    VT_FAMILY = 16,
    VT_VEC_OF_MASK_BITS = 18,
    VT_NAME = 20,
    VT_HEIGHT = 22,
    VT_WIDTH = 24,
    VT_RADIUS = 26,
    VT_DENSITY = 28,
    VT_FRICTION = 30,
    VT_RESTITUTION = 32,
    VT_ANGLE = 34,
    VT_INIT_ANGULAR_VELOCITY = 36,
    VT_FREQUENCY = 38,
    VT_LINEAR_DAMPING = 40,
    VT_ANGULAR_DAMPING = 42,
    VT_GRAVITY_SCALE = 44,
    VT_RESISTIVITY = 46,
    VT_IS_FIRST_HOVERED = 48,
    VT_IS_LAST_HOVERED = 50,
    VT_IS_FIRST_SELECTED = 52,
    VT_IS_LAST_SELECTED = 54,
    VT_IS_HIDDEN = 56,
    VT_IS_FIXED_ROTATION = 58,
    VT_IS_ALIVE = 60,
    VT_ALLOW_SLEEP = 62,
    VT_AWAKE = 64,
    VT_IS_BULLET = 66,
    VT_REQUESTING_RECREATION = 68,
    VT_CONTROLLER_TYPE = 70,
    VT_SHAPE = 72,
    VT_TYPE = 74,
    VT_VEC_OF_EDGES = 76,
    VT_VERTICES = 78,
    VT_JOINTS = 80,
    VT_OFF_SET = 82,
    VT_POSITION = 84,
    VT_INIT_LINEAR_VELOCITY = 86,
    VT_DIRECTION = 88,
    VT_SPEED = 90,
    VT_PHYSICS_PROPERTIES = 92,
    VT_COLOR = 94,
    VT_TEXTURE_INFO = 96
  };
  int32_t layer_index() const {
    return GetField<int32_t>(VT_LAYER_INDEX, 0);
  }
  int32_t cluster_index() const {
    return GetField<int32_t>(VT_CLUSTER_INDEX, 0);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t deletion_index() const {
    return GetField<int32_t>(VT_DELETION_INDEX, 0);
  }
  float life_span() const {
    return GetField<float>(VT_LIFE_SPAN, 0.0f);
  }
  int32_t group_index() const {
    return GetField<int32_t>(VT_GROUP_INDEX, 0);
  }
  int32_t family() const {
    return GetField<int32_t>(VT_FAMILY, 0);
  }
  const flatbuffers::Vector<int32_t> *vec_of_mask_bits() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VEC_OF_MASK_BITS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float density() const {
    return GetField<float>(VT_DENSITY, 0.0f);
  }
  float friction() const {
    return GetField<float>(VT_FRICTION, 0.0f);
  }
  float restitution() const {
    return GetField<float>(VT_RESTITUTION, 0.0f);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  float init_angular_velocity() const {
    return GetField<float>(VT_INIT_ANGULAR_VELOCITY, 0.0f);
  }
  float frequency() const {
    return GetField<float>(VT_FREQUENCY, 0.0f);
  }
  float linear_damping() const {
    return GetField<float>(VT_LINEAR_DAMPING, 0.0f);
  }
  float angular_damping() const {
    return GetField<float>(VT_ANGULAR_DAMPING, 0.0f);
  }
  float gravity_scale() const {
    return GetField<float>(VT_GRAVITY_SCALE, 0.0f);
  }
  float resistivity() const {
    return GetField<float>(VT_RESISTIVITY, 0.0f);
  }
  bool is_first_hovered() const {
    return GetField<uint8_t>(VT_IS_FIRST_HOVERED, 0) != 0;
  }
  bool is_last_hovered() const {
    return GetField<uint8_t>(VT_IS_LAST_HOVERED, 0) != 0;
  }
  bool is_first_selected() const {
    return GetField<uint8_t>(VT_IS_FIRST_SELECTED, 0) != 0;
  }
  bool is_last_selected() const {
    return GetField<uint8_t>(VT_IS_LAST_SELECTED, 0) != 0;
  }
  bool is_hidden() const {
    return GetField<uint8_t>(VT_IS_HIDDEN, 0) != 0;
  }
  bool is_fixed_rotation() const {
    return GetField<uint8_t>(VT_IS_FIXED_ROTATION, 0) != 0;
  }
  bool is_alive() const {
    return GetField<uint8_t>(VT_IS_ALIVE, 0) != 0;
  }
  bool allow_sleep() const {
    return GetField<uint8_t>(VT_ALLOW_SLEEP, 0) != 0;
  }
  bool awake() const {
    return GetField<uint8_t>(VT_AWAKE, 0) != 0;
  }
  bool is_bullet() const {
    return GetField<uint8_t>(VT_IS_BULLET, 0) != 0;
  }
  bool requesting_recreation() const {
    return GetField<uint8_t>(VT_REQUESTING_RECREATION, 0) != 0;
  }
  int32_t controller_type() const {
    return GetField<int32_t>(VT_CONTROLLER_TYPE, 0);
  }
  int32_t shape() const {
    return GetField<int32_t>(VT_SHAPE, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>> *vec_of_edges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>> *>(VT_VEC_OF_EDGES);
  }
  const flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *> *vertices() const {
    return GetPointer<const flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>> *joints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>> *>(VT_JOINTS);
  }
  const SquareBox::DSUGWOM::Vec2 *off_set() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_OFF_SET);
  }
  const SquareBox::DSUGWOM::Vec2 *position() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_POSITION);
  }
  const SquareBox::DSUGWOM::Vec2 *init_linear_velocity() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_INIT_LINEAR_VELOCITY);
  }
  const SquareBox::DSUGWOM::Vec2 *direction() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_DIRECTION);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  int32_t physics_properties() const {
    return GetField<int32_t>(VT_PHYSICS_PROPERTIES, 0);
  }
  const SquareBox::DSUGWOM::Ivec4 *color() const {
    return GetStruct<const SquareBox::DSUGWOM::Ivec4 *>(VT_COLOR);
  }
  const SquareBox::DSUGWOM::TextureInfo *texture_info() const {
    return GetPointer<const SquareBox::DSUGWOM::TextureInfo *>(VT_TEXTURE_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAYER_INDEX) &&
           VerifyField<int32_t>(verifier, VT_CLUSTER_INDEX) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_DELETION_INDEX) &&
           VerifyField<float>(verifier, VT_LIFE_SPAN) &&
           VerifyField<int32_t>(verifier, VT_GROUP_INDEX) &&
           VerifyField<int32_t>(verifier, VT_FAMILY) &&
           VerifyOffset(verifier, VT_VEC_OF_MASK_BITS) &&
           verifier.VerifyVector(vec_of_mask_bits()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_DENSITY) &&
           VerifyField<float>(verifier, VT_FRICTION) &&
           VerifyField<float>(verifier, VT_RESTITUTION) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<float>(verifier, VT_INIT_ANGULAR_VELOCITY) &&
           VerifyField<float>(verifier, VT_FREQUENCY) &&
           VerifyField<float>(verifier, VT_LINEAR_DAMPING) &&
           VerifyField<float>(verifier, VT_ANGULAR_DAMPING) &&
           VerifyField<float>(verifier, VT_GRAVITY_SCALE) &&
           VerifyField<float>(verifier, VT_RESISTIVITY) &&
           VerifyField<uint8_t>(verifier, VT_IS_FIRST_HOVERED) &&
           VerifyField<uint8_t>(verifier, VT_IS_LAST_HOVERED) &&
           VerifyField<uint8_t>(verifier, VT_IS_FIRST_SELECTED) &&
           VerifyField<uint8_t>(verifier, VT_IS_LAST_SELECTED) &&
           VerifyField<uint8_t>(verifier, VT_IS_HIDDEN) &&
           VerifyField<uint8_t>(verifier, VT_IS_FIXED_ROTATION) &&
           VerifyField<uint8_t>(verifier, VT_IS_ALIVE) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_SLEEP) &&
           VerifyField<uint8_t>(verifier, VT_AWAKE) &&
           VerifyField<uint8_t>(verifier, VT_IS_BULLET) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTING_RECREATION) &&
           VerifyField<int32_t>(verifier, VT_CONTROLLER_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SHAPE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VEC_OF_EDGES) &&
           verifier.VerifyVector(vec_of_edges()) &&
           verifier.VerifyVectorOfTables(vec_of_edges()) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(vertices()) &&
           VerifyOffset(verifier, VT_JOINTS) &&
           verifier.VerifyVector(joints()) &&
           verifier.VerifyVectorOfTables(joints()) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_OFF_SET) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_POSITION) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_INIT_LINEAR_VELOCITY) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_DIRECTION) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_PHYSICS_PROPERTIES) &&
           VerifyField<SquareBox::DSUGWOM::Ivec4>(verifier, VT_COLOR) &&
           VerifyOffset(verifier, VT_TEXTURE_INFO) &&
           verifier.VerifyTable(texture_info()) &&
           verifier.EndTable();
  }
};

struct ClusterObjectBuilder {
  typedef ClusterObject Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layer_index(int32_t layer_index) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_LAYER_INDEX, layer_index, 0);
  }
  void add_cluster_index(int32_t cluster_index) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_CLUSTER_INDEX, cluster_index, 0);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_INDEX, index, 0);
  }
  void add_deletion_index(int32_t deletion_index) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_DELETION_INDEX, deletion_index, 0);
  }
  void add_life_span(float life_span) {
    fbb_.AddElement<float>(ClusterObject::VT_LIFE_SPAN, life_span, 0.0f);
  }
  void add_group_index(int32_t group_index) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_GROUP_INDEX, group_index, 0);
  }
  void add_family(int32_t family) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_FAMILY, family, 0);
  }
  void add_vec_of_mask_bits(flatbuffers::Offset<flatbuffers::Vector<int32_t>> vec_of_mask_bits) {
    fbb_.AddOffset(ClusterObject::VT_VEC_OF_MASK_BITS, vec_of_mask_bits);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ClusterObject::VT_NAME, name);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(ClusterObject::VT_HEIGHT, height, 0.0f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(ClusterObject::VT_WIDTH, width, 0.0f);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ClusterObject::VT_RADIUS, radius, 0.0f);
  }
  void add_density(float density) {
    fbb_.AddElement<float>(ClusterObject::VT_DENSITY, density, 0.0f);
  }
  void add_friction(float friction) {
    fbb_.AddElement<float>(ClusterObject::VT_FRICTION, friction, 0.0f);
  }
  void add_restitution(float restitution) {
    fbb_.AddElement<float>(ClusterObject::VT_RESTITUTION, restitution, 0.0f);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(ClusterObject::VT_ANGLE, angle, 0.0f);
  }
  void add_init_angular_velocity(float init_angular_velocity) {
    fbb_.AddElement<float>(ClusterObject::VT_INIT_ANGULAR_VELOCITY, init_angular_velocity, 0.0f);
  }
  void add_frequency(float frequency) {
    fbb_.AddElement<float>(ClusterObject::VT_FREQUENCY, frequency, 0.0f);
  }
  void add_linear_damping(float linear_damping) {
    fbb_.AddElement<float>(ClusterObject::VT_LINEAR_DAMPING, linear_damping, 0.0f);
  }
  void add_angular_damping(float angular_damping) {
    fbb_.AddElement<float>(ClusterObject::VT_ANGULAR_DAMPING, angular_damping, 0.0f);
  }
  void add_gravity_scale(float gravity_scale) {
    fbb_.AddElement<float>(ClusterObject::VT_GRAVITY_SCALE, gravity_scale, 0.0f);
  }
  void add_resistivity(float resistivity) {
    fbb_.AddElement<float>(ClusterObject::VT_RESISTIVITY, resistivity, 0.0f);
  }
  void add_is_first_hovered(bool is_first_hovered) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_FIRST_HOVERED, static_cast<uint8_t>(is_first_hovered), 0);
  }
  void add_is_last_hovered(bool is_last_hovered) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_LAST_HOVERED, static_cast<uint8_t>(is_last_hovered), 0);
  }
  void add_is_first_selected(bool is_first_selected) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_FIRST_SELECTED, static_cast<uint8_t>(is_first_selected), 0);
  }
  void add_is_last_selected(bool is_last_selected) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_LAST_SELECTED, static_cast<uint8_t>(is_last_selected), 0);
  }
  void add_is_hidden(bool is_hidden) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_HIDDEN, static_cast<uint8_t>(is_hidden), 0);
  }
  void add_is_fixed_rotation(bool is_fixed_rotation) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_FIXED_ROTATION, static_cast<uint8_t>(is_fixed_rotation), 0);
  }
  void add_is_alive(bool is_alive) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_ALIVE, static_cast<uint8_t>(is_alive), 0);
  }
  void add_allow_sleep(bool allow_sleep) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_ALLOW_SLEEP, static_cast<uint8_t>(allow_sleep), 0);
  }
  void add_awake(bool awake) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_AWAKE, static_cast<uint8_t>(awake), 0);
  }
  void add_is_bullet(bool is_bullet) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_IS_BULLET, static_cast<uint8_t>(is_bullet), 0);
  }
  void add_requesting_recreation(bool requesting_recreation) {
    fbb_.AddElement<uint8_t>(ClusterObject::VT_REQUESTING_RECREATION, static_cast<uint8_t>(requesting_recreation), 0);
  }
  void add_controller_type(int32_t controller_type) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_CONTROLLER_TYPE, controller_type, 0);
  }
  void add_shape(int32_t shape) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_SHAPE, shape, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_TYPE, type, 0);
  }
  void add_vec_of_edges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>>> vec_of_edges) {
    fbb_.AddOffset(ClusterObject::VT_VEC_OF_EDGES, vec_of_edges);
  }
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *>> vertices) {
    fbb_.AddOffset(ClusterObject::VT_VERTICES, vertices);
  }
  void add_joints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>>> joints) {
    fbb_.AddOffset(ClusterObject::VT_JOINTS, joints);
  }
  void add_off_set(const SquareBox::DSUGWOM::Vec2 *off_set) {
    fbb_.AddStruct(ClusterObject::VT_OFF_SET, off_set);
  }
  void add_position(const SquareBox::DSUGWOM::Vec2 *position) {
    fbb_.AddStruct(ClusterObject::VT_POSITION, position);
  }
  void add_init_linear_velocity(const SquareBox::DSUGWOM::Vec2 *init_linear_velocity) {
    fbb_.AddStruct(ClusterObject::VT_INIT_LINEAR_VELOCITY, init_linear_velocity);
  }
  void add_direction(const SquareBox::DSUGWOM::Vec2 *direction) {
    fbb_.AddStruct(ClusterObject::VT_DIRECTION, direction);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ClusterObject::VT_SPEED, speed, 0.0f);
  }
  void add_physics_properties(int32_t physics_properties) {
    fbb_.AddElement<int32_t>(ClusterObject::VT_PHYSICS_PROPERTIES, physics_properties, 0);
  }
  void add_color(const SquareBox::DSUGWOM::Ivec4 *color) {
    fbb_.AddStruct(ClusterObject::VT_COLOR, color);
  }
  void add_texture_info(flatbuffers::Offset<SquareBox::DSUGWOM::TextureInfo> texture_info) {
    fbb_.AddOffset(ClusterObject::VT_TEXTURE_INFO, texture_info);
  }
  explicit ClusterObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClusterObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClusterObject>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClusterObject> CreateClusterObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t layer_index = 0,
    int32_t cluster_index = 0,
    int32_t index = 0,
    int32_t deletion_index = 0,
    float life_span = 0.0f,
    int32_t group_index = 0,
    int32_t family = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> vec_of_mask_bits = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float height = 0.0f,
    float width = 0.0f,
    float radius = 0.0f,
    float density = 0.0f,
    float friction = 0.0f,
    float restitution = 0.0f,
    float angle = 0.0f,
    float init_angular_velocity = 0.0f,
    float frequency = 0.0f,
    float linear_damping = 0.0f,
    float angular_damping = 0.0f,
    float gravity_scale = 0.0f,
    float resistivity = 0.0f,
    bool is_first_hovered = false,
    bool is_last_hovered = false,
    bool is_first_selected = false,
    bool is_last_selected = false,
    bool is_hidden = false,
    bool is_fixed_rotation = false,
    bool is_alive = false,
    bool allow_sleep = false,
    bool awake = false,
    bool is_bullet = false,
    bool requesting_recreation = false,
    int32_t controller_type = 0,
    int32_t shape = 0,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>>> vec_of_edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SquareBox::DSUGWOM::Vec2 *>> vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>>> joints = 0,
    const SquareBox::DSUGWOM::Vec2 *off_set = 0,
    const SquareBox::DSUGWOM::Vec2 *position = 0,
    const SquareBox::DSUGWOM::Vec2 *init_linear_velocity = 0,
    const SquareBox::DSUGWOM::Vec2 *direction = 0,
    float speed = 0.0f,
    int32_t physics_properties = 0,
    const SquareBox::DSUGWOM::Ivec4 *color = 0,
    flatbuffers::Offset<SquareBox::DSUGWOM::TextureInfo> texture_info = 0) {
  ClusterObjectBuilder builder_(_fbb);
  builder_.add_texture_info(texture_info);
  builder_.add_color(color);
  builder_.add_physics_properties(physics_properties);
  builder_.add_speed(speed);
  builder_.add_direction(direction);
  builder_.add_init_linear_velocity(init_linear_velocity);
  builder_.add_position(position);
  builder_.add_off_set(off_set);
  builder_.add_joints(joints);
  builder_.add_vertices(vertices);
  builder_.add_vec_of_edges(vec_of_edges);
  builder_.add_type(type);
  builder_.add_shape(shape);
  builder_.add_controller_type(controller_type);
  builder_.add_resistivity(resistivity);
  builder_.add_gravity_scale(gravity_scale);
  builder_.add_angular_damping(angular_damping);
  builder_.add_linear_damping(linear_damping);
  builder_.add_frequency(frequency);
  builder_.add_init_angular_velocity(init_angular_velocity);
  builder_.add_angle(angle);
  builder_.add_restitution(restitution);
  builder_.add_friction(friction);
  builder_.add_density(density);
  builder_.add_radius(radius);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_name(name);
  builder_.add_vec_of_mask_bits(vec_of_mask_bits);
  builder_.add_family(family);
  builder_.add_group_index(group_index);
  builder_.add_life_span(life_span);
  builder_.add_deletion_index(deletion_index);
  builder_.add_index(index);
  builder_.add_cluster_index(cluster_index);
  builder_.add_layer_index(layer_index);
  builder_.add_requesting_recreation(requesting_recreation);
  builder_.add_is_bullet(is_bullet);
  builder_.add_awake(awake);
  builder_.add_allow_sleep(allow_sleep);
  builder_.add_is_alive(is_alive);
  builder_.add_is_fixed_rotation(is_fixed_rotation);
  builder_.add_is_hidden(is_hidden);
  builder_.add_is_last_selected(is_last_selected);
  builder_.add_is_first_selected(is_first_selected);
  builder_.add_is_last_hovered(is_last_hovered);
  builder_.add_is_first_hovered(is_first_hovered);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClusterObject> CreateClusterObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t layer_index = 0,
    int32_t cluster_index = 0,
    int32_t index = 0,
    int32_t deletion_index = 0,
    float life_span = 0.0f,
    int32_t group_index = 0,
    int32_t family = 0,
    const std::vector<int32_t> *vec_of_mask_bits = nullptr,
    const char *name = nullptr,
    float height = 0.0f,
    float width = 0.0f,
    float radius = 0.0f,
    float density = 0.0f,
    float friction = 0.0f,
    float restitution = 0.0f,
    float angle = 0.0f,
    float init_angular_velocity = 0.0f,
    float frequency = 0.0f,
    float linear_damping = 0.0f,
    float angular_damping = 0.0f,
    float gravity_scale = 0.0f,
    float resistivity = 0.0f,
    bool is_first_hovered = false,
    bool is_last_hovered = false,
    bool is_first_selected = false,
    bool is_last_selected = false,
    bool is_hidden = false,
    bool is_fixed_rotation = false,
    bool is_alive = false,
    bool allow_sleep = false,
    bool awake = false,
    bool is_bullet = false,
    bool requesting_recreation = false,
    int32_t controller_type = 0,
    int32_t shape = 0,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>> *vec_of_edges = nullptr,
    const std::vector<SquareBox::DSUGWOM::Vec2> *vertices = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>> *joints = nullptr,
    const SquareBox::DSUGWOM::Vec2 *off_set = 0,
    const SquareBox::DSUGWOM::Vec2 *position = 0,
    const SquareBox::DSUGWOM::Vec2 *init_linear_velocity = 0,
    const SquareBox::DSUGWOM::Vec2 *direction = 0,
    float speed = 0.0f,
    int32_t physics_properties = 0,
    const SquareBox::DSUGWOM::Ivec4 *color = 0,
    flatbuffers::Offset<SquareBox::DSUGWOM::TextureInfo> texture_info = 0) {
  auto vec_of_mask_bits__ = vec_of_mask_bits ? _fbb.CreateVector<int32_t>(*vec_of_mask_bits) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto vec_of_edges__ = vec_of_edges ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfVec2>>(*vec_of_edges) : 0;
  auto vertices__ = vertices ? _fbb.CreateVectorOfStructs<SquareBox::DSUGWOM::Vec2>(*vertices) : 0;
  auto joints__ = joints ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::Joint>>(*joints) : 0;
  return SquareBox::DSUGWOM::CreateClusterObject(
      _fbb,
      layer_index,
      cluster_index,
      index,
      deletion_index,
      life_span,
      group_index,
      family,
      vec_of_mask_bits__,
      name__,
      height,
      width,
      radius,
      density,
      friction,
      restitution,
      angle,
      init_angular_velocity,
      frequency,
      linear_damping,
      angular_damping,
      gravity_scale,
      resistivity,
      is_first_hovered,
      is_last_hovered,
      is_first_selected,
      is_last_selected,
      is_hidden,
      is_fixed_rotation,
      is_alive,
      allow_sleep,
      awake,
      is_bullet,
      requesting_recreation,
      controller_type,
      shape,
      type,
      vec_of_edges__,
      vertices__,
      joints__,
      off_set,
      position,
      init_linear_velocity,
      direction,
      speed,
      physics_properties,
      color,
      texture_info);
}

struct WorldCluster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorldClusterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_DELETION_INDEX = 6,
    VT_NAME = 8,
    VT_IS_SELECTED = 10,
    VT_CLUSTER_OBJECTS = 12
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t deletion_index() const {
    return GetField<int32_t>(VT_DELETION_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool is_selected() const {
    return GetField<uint8_t>(VT_IS_SELECTED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>> *cluster_objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>> *>(VT_CLUSTER_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_DELETION_INDEX) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_SELECTED) &&
           VerifyOffset(verifier, VT_CLUSTER_OBJECTS) &&
           verifier.VerifyVector(cluster_objects()) &&
           verifier.VerifyVectorOfTables(cluster_objects()) &&
           verifier.EndTable();
  }
};

struct WorldClusterBuilder {
  typedef WorldCluster Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(WorldCluster::VT_INDEX, index, 0);
  }
  void add_deletion_index(int32_t deletion_index) {
    fbb_.AddElement<int32_t>(WorldCluster::VT_DELETION_INDEX, deletion_index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(WorldCluster::VT_NAME, name);
  }
  void add_is_selected(bool is_selected) {
    fbb_.AddElement<uint8_t>(WorldCluster::VT_IS_SELECTED, static_cast<uint8_t>(is_selected), 0);
  }
  void add_cluster_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>>> cluster_objects) {
    fbb_.AddOffset(WorldCluster::VT_CLUSTER_OBJECTS, cluster_objects);
  }
  explicit WorldClusterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WorldCluster> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorldCluster>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorldCluster> CreateWorldCluster(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t deletion_index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_selected = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>>> cluster_objects = 0) {
  WorldClusterBuilder builder_(_fbb);
  builder_.add_cluster_objects(cluster_objects);
  builder_.add_name(name);
  builder_.add_deletion_index(deletion_index);
  builder_.add_index(index);
  builder_.add_is_selected(is_selected);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorldCluster> CreateWorldClusterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t deletion_index = 0,
    const char *name = nullptr,
    bool is_selected = false,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>> *cluster_objects = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto cluster_objects__ = cluster_objects ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::ClusterObject>>(*cluster_objects) : 0;
  return SquareBox::DSUGWOM::CreateWorldCluster(
      _fbb,
      index,
      deletion_index,
      name__,
      is_selected,
      cluster_objects__);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OPACITY = 6,
    VT_IS_VISIBLE = 8,
    VT_IS_LOCKED = 10,
    VT_TILING = 12,
    VT_SINGLE_TEXTURES = 14,
    VT_TILED_TEXTURES = 16,
    VT_SUB_TEXTURES = 18,
    VT_TILE_SYSTEM_ORIGN_X = 20,
    VT_TILE_SYSTEM_ORIGN_Y = 22,
    VT_TILE_SYSTEM_WIDTH = 24,
    VT_TILE_SYSTEM_HEIGHT = 26,
    VT_TILE_SYSTEM_TILE_SIZE = 28,
    VT_TILE_SYSTEM_DATA = 30,
    VT_ALIVE_CLUSTER_OBJECTS = 32,
    VT_WORLD_CLUSTERS = 34
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t opacity() const {
    return GetField<int32_t>(VT_OPACITY, 0);
  }
  bool is_visible() const {
    return GetField<uint8_t>(VT_IS_VISIBLE, 0) != 0;
  }
  bool is_locked() const {
    return GetField<uint8_t>(VT_IS_LOCKED, 0) != 0;
  }
  int32_t tiling() const {
    return GetField<int32_t>(VT_TILING, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *single_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *>(VT_SINGLE_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *tiled_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *>(VT_TILED_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>> *sub_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>> *>(VT_SUB_TEXTURES);
  }
  float tile_system_orign_x() const {
    return GetField<float>(VT_TILE_SYSTEM_ORIGN_X, 0.0f);
  }
  float tile_system_orign_y() const {
    return GetField<float>(VT_TILE_SYSTEM_ORIGN_Y, 0.0f);
  }
  float tile_system_width() const {
    return GetField<float>(VT_TILE_SYSTEM_WIDTH, 0.0f);
  }
  float tile_system_height() const {
    return GetField<float>(VT_TILE_SYSTEM_HEIGHT, 0.0f);
  }
  float tile_system_tile_size() const {
    return GetField<float>(VT_TILE_SYSTEM_TILE_SIZE, 0.0f);
  }
  const flatbuffers::Vector<int32_t> *tile_system_data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TILE_SYSTEM_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>> *alive_cluster_objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>> *>(VT_ALIVE_CLUSTER_OBJECTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>> *world_clusters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>> *>(VT_WORLD_CLUSTERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOCKED) &&
           VerifyField<int32_t>(verifier, VT_TILING) &&
           VerifyOffset(verifier, VT_SINGLE_TEXTURES) &&
           verifier.VerifyVector(single_textures()) &&
           verifier.VerifyVectorOfTables(single_textures()) &&
           VerifyOffset(verifier, VT_TILED_TEXTURES) &&
           verifier.VerifyVector(tiled_textures()) &&
           verifier.VerifyVectorOfTables(tiled_textures()) &&
           VerifyOffset(verifier, VT_SUB_TEXTURES) &&
           verifier.VerifyVector(sub_textures()) &&
           verifier.VerifyVectorOfTables(sub_textures()) &&
           VerifyField<float>(verifier, VT_TILE_SYSTEM_ORIGN_X) &&
           VerifyField<float>(verifier, VT_TILE_SYSTEM_ORIGN_Y) &&
           VerifyField<float>(verifier, VT_TILE_SYSTEM_WIDTH) &&
           VerifyField<float>(verifier, VT_TILE_SYSTEM_HEIGHT) &&
           VerifyField<float>(verifier, VT_TILE_SYSTEM_TILE_SIZE) &&
           VerifyOffset(verifier, VT_TILE_SYSTEM_DATA) &&
           verifier.VerifyVector(tile_system_data()) &&
           VerifyOffset(verifier, VT_ALIVE_CLUSTER_OBJECTS) &&
           verifier.VerifyVector(alive_cluster_objects()) &&
           verifier.VerifyVectorOfTables(alive_cluster_objects()) &&
           VerifyOffset(verifier, VT_WORLD_CLUSTERS) &&
           verifier.VerifyVector(world_clusters()) &&
           verifier.VerifyVectorOfTables(world_clusters()) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Layer::VT_NAME, name);
  }
  void add_opacity(int32_t opacity) {
    fbb_.AddElement<int32_t>(Layer::VT_OPACITY, opacity, 0);
  }
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(Layer::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible), 0);
  }
  void add_is_locked(bool is_locked) {
    fbb_.AddElement<uint8_t>(Layer::VT_IS_LOCKED, static_cast<uint8_t>(is_locked), 0);
  }
  void add_tiling(int32_t tiling) {
    fbb_.AddElement<int32_t>(Layer::VT_TILING, tiling, 0);
  }
  void add_single_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>> single_textures) {
    fbb_.AddOffset(Layer::VT_SINGLE_TEXTURES, single_textures);
  }
  void add_tiled_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>> tiled_textures) {
    fbb_.AddOffset(Layer::VT_TILED_TEXTURES, tiled_textures);
  }
  void add_sub_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>>> sub_textures) {
    fbb_.AddOffset(Layer::VT_SUB_TEXTURES, sub_textures);
  }
  void add_tile_system_orign_x(float tile_system_orign_x) {
    fbb_.AddElement<float>(Layer::VT_TILE_SYSTEM_ORIGN_X, tile_system_orign_x, 0.0f);
  }
  void add_tile_system_orign_y(float tile_system_orign_y) {
    fbb_.AddElement<float>(Layer::VT_TILE_SYSTEM_ORIGN_Y, tile_system_orign_y, 0.0f);
  }
  void add_tile_system_width(float tile_system_width) {
    fbb_.AddElement<float>(Layer::VT_TILE_SYSTEM_WIDTH, tile_system_width, 0.0f);
  }
  void add_tile_system_height(float tile_system_height) {
    fbb_.AddElement<float>(Layer::VT_TILE_SYSTEM_HEIGHT, tile_system_height, 0.0f);
  }
  void add_tile_system_tile_size(float tile_system_tile_size) {
    fbb_.AddElement<float>(Layer::VT_TILE_SYSTEM_TILE_SIZE, tile_system_tile_size, 0.0f);
  }
  void add_tile_system_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> tile_system_data) {
    fbb_.AddOffset(Layer::VT_TILE_SYSTEM_DATA, tile_system_data);
  }
  void add_alive_cluster_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>>> alive_cluster_objects) {
    fbb_.AddOffset(Layer::VT_ALIVE_CLUSTER_OBJECTS, alive_cluster_objects);
  }
  void add_world_clusters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>>> world_clusters) {
    fbb_.AddOffset(Layer::VT_WORLD_CLUSTERS, world_clusters);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t opacity = 0,
    bool is_visible = false,
    bool is_locked = false,
    int32_t tiling = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>> single_textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>> tiled_textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>>> sub_textures = 0,
    float tile_system_orign_x = 0.0f,
    float tile_system_orign_y = 0.0f,
    float tile_system_width = 0.0f,
    float tile_system_height = 0.0f,
    float tile_system_tile_size = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> tile_system_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>>> alive_cluster_objects = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>>> world_clusters = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_world_clusters(world_clusters);
  builder_.add_alive_cluster_objects(alive_cluster_objects);
  builder_.add_tile_system_data(tile_system_data);
  builder_.add_tile_system_tile_size(tile_system_tile_size);
  builder_.add_tile_system_height(tile_system_height);
  builder_.add_tile_system_width(tile_system_width);
  builder_.add_tile_system_orign_y(tile_system_orign_y);
  builder_.add_tile_system_orign_x(tile_system_orign_x);
  builder_.add_sub_textures(sub_textures);
  builder_.add_tiled_textures(tiled_textures);
  builder_.add_single_textures(single_textures);
  builder_.add_tiling(tiling);
  builder_.add_opacity(opacity);
  builder_.add_name(name);
  builder_.add_is_locked(is_locked);
  builder_.add_is_visible(is_visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<Layer> CreateLayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t opacity = 0,
    bool is_visible = false,
    bool is_locked = false,
    int32_t tiling = 0,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *single_textures = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>> *tiled_textures = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>> *sub_textures = nullptr,
    float tile_system_orign_x = 0.0f,
    float tile_system_orign_y = 0.0f,
    float tile_system_width = 0.0f,
    float tile_system_height = 0.0f,
    float tile_system_tile_size = 0.0f,
    const std::vector<int32_t> *tile_system_data = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>> *alive_cluster_objects = nullptr,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>> *world_clusters = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto single_textures__ = single_textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>(*single_textures) : 0;
  auto tiled_textures__ = tiled_textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::ParentTexture>>(*tiled_textures) : 0;
  auto sub_textures__ = sub_textures ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::SubTexture>>(*sub_textures) : 0;
  auto tile_system_data__ = tile_system_data ? _fbb.CreateVector<int32_t>(*tile_system_data) : 0;
  auto alive_cluster_objects__ = alive_cluster_objects ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::PairOfInt>>(*alive_cluster_objects) : 0;
  auto world_clusters__ = world_clusters ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::WorldCluster>>(*world_clusters) : 0;
  return SquareBox::DSUGWOM::CreateLayer(
      _fbb,
      name__,
      opacity,
      is_visible,
      is_locked,
      tiling,
      single_textures__,
      tiled_textures__,
      sub_textures__,
      tile_system_orign_x,
      tile_system_orign_y,
      tile_system_width,
      tile_system_height,
      tile_system_tile_size,
      tile_system_data__,
      alive_cluster_objects__,
      world_clusters__);
}

struct SquareBoxLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareBoxLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_SCALE = 4,
    VT_CAMERA_POSITION = 6,
    VT_ACTIVE_CAMERA_INDEX = 8,
    VT_LAYERS = 10
  };
  float camera_scale() const {
    return GetField<float>(VT_CAMERA_SCALE, 0.0f);
  }
  const SquareBox::DSUGWOM::Vec2 *camera_position() const {
    return GetStruct<const SquareBox::DSUGWOM::Vec2 *>(VT_CAMERA_POSITION);
  }
  int32_t active_camera_index() const {
    return GetField<int32_t>(VT_ACTIVE_CAMERA_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>> *layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>> *>(VT_LAYERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CAMERA_SCALE) &&
           VerifyField<SquareBox::DSUGWOM::Vec2>(verifier, VT_CAMERA_POSITION) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_CAMERA_INDEX) &&
           VerifyOffset(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           verifier.EndTable();
  }
};

struct SquareBoxLevelBuilder {
  typedef SquareBoxLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_scale(float camera_scale) {
    fbb_.AddElement<float>(SquareBoxLevel::VT_CAMERA_SCALE, camera_scale, 0.0f);
  }
  void add_camera_position(const SquareBox::DSUGWOM::Vec2 *camera_position) {
    fbb_.AddStruct(SquareBoxLevel::VT_CAMERA_POSITION, camera_position);
  }
  void add_active_camera_index(int32_t active_camera_index) {
    fbb_.AddElement<int32_t>(SquareBoxLevel::VT_ACTIVE_CAMERA_INDEX, active_camera_index, 0);
  }
  void add_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>>> layers) {
    fbb_.AddOffset(SquareBoxLevel::VT_LAYERS, layers);
  }
  explicit SquareBoxLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquareBoxLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareBoxLevel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareBoxLevel> CreateSquareBoxLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    float camera_scale = 0.0f,
    const SquareBox::DSUGWOM::Vec2 *camera_position = 0,
    int32_t active_camera_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>>> layers = 0) {
  SquareBoxLevelBuilder builder_(_fbb);
  builder_.add_layers(layers);
  builder_.add_active_camera_index(active_camera_index);
  builder_.add_camera_position(camera_position);
  builder_.add_camera_scale(camera_scale);
  return builder_.Finish();
}

inline flatbuffers::Offset<SquareBoxLevel> CreateSquareBoxLevelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float camera_scale = 0.0f,
    const SquareBox::DSUGWOM::Vec2 *camera_position = 0,
    int32_t active_camera_index = 0,
    const std::vector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>> *layers = nullptr) {
  auto layers__ = layers ? _fbb.CreateVector<flatbuffers::Offset<SquareBox::DSUGWOM::Layer>>(*layers) : 0;
  return SquareBox::DSUGWOM::CreateSquareBoxLevel(
      _fbb,
      camera_scale,
      camera_position,
      active_camera_index,
      layers__);
}

inline const SquareBox::DSUGWOM::SquareBoxLevel *GetSquareBoxLevel(const void *buf) {
  return flatbuffers::GetRoot<SquareBox::DSUGWOM::SquareBoxLevel>(buf);
}

inline const SquareBox::DSUGWOM::SquareBoxLevel *GetSizePrefixedSquareBoxLevel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SquareBox::DSUGWOM::SquareBoxLevel>(buf);
}

inline bool VerifySquareBoxLevelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SquareBox::DSUGWOM::SquareBoxLevel>(nullptr);
}

inline bool VerifySizePrefixedSquareBoxLevelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SquareBox::DSUGWOM::SquareBoxLevel>(nullptr);
}

inline void FinishSquareBoxLevelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SquareBox::DSUGWOM::SquareBoxLevel> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSquareBoxLevelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SquareBox::DSUGWOM::SquareBoxLevel> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DSUGWOM
}  // namespace SquareBox

#endif  // FLATBUFFERS_GENERATED_DSUGWOM_SQUAREBOX_DSUGWOM_H_
